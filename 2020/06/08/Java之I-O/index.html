<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/128128.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/3232.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/1616.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"onlyear.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="IO体系Java IO 也称为IO流，IO &#x3D; 流，它的核心就是对文件的操作，对于 字节 、字符类型的输入和输出流。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java之I&#x2F;O">
<meta property="og:url" content="http://onlyear.com/2020/06/08/Java%E4%B9%8BI-O/index.html">
<meta property="og:site_name" content="imarktsh的博客">
<meta property="og:description" content="IO体系Java IO 也称为IO流，IO &#x3D; 流，它的核心就是对文件的操作，对于 字节 、字符类型的输入和输出流。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200608133604231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200608134713173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200608133738275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2020-06-08T05:48:00.000Z">
<meta property="article:modified_time" content="2020-06-08T05:48:58.000Z">
<meta property="article:author" content="imarktsh">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200608133604231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70">

<link rel="canonical" href="http://onlyear.com/2020/06/08/Java%E4%B9%8BI-O/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java之I/O | imarktsh的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">imarktsh的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">多沉淀 多复盘</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://onlyear.com/2020/06/08/Java%E4%B9%8BI-O/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://img-blog.csdnimg.cn/2020053010414625.jpg">
      <meta itemprop="name" content="imarktsh">
      <meta itemprop="description" content="明天一定学">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imarktsh的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java之I/O
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-08 13:48:00 / 修改时间：13:48:58" itemprop="dateCreated datePublished" datetime="2020-06-08T13:48:00+08:00">2020-06-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="IO体系"><a href="#IO体系" class="headerlink" title="IO体系"></a>IO体系</h2><p>Java IO 也称为IO流，IO = 流，它的核心就是对文件的操作，对于 字节 、字符类型的输入和输出流。</p>
<span id="more"></span>

<p>IO是指对数据流的输入和输出，也称为IO流，IO流主要分为两大类，<strong>字节流和字符流</strong>。字节流可以处理任何类型的数据，如图片，视频等，字符流只能处理字符类型的数据。</p>
<p>IO流的本质是数据传输，并且流是单向的。</p>
<p><strong>常用的字节流FileInputStream、FileOutputStream、ObjectInputStream、ObjectOutputStream。</strong></p>
<p>IO分阻塞型IO和非阻塞型IO（NIO）</p>
<p>阻塞型IO在读取数据时，<strong>如果数据未到达，会一直阻塞到读取到数据为止</strong>，所以称为阻塞型IO，在高并发的环境下性能不佳。</p>
<p>NIO不是使用 “流” 来作为数据的传输方式，而是使用通道，通道的数据传输是双向的，且NIO的数据写入和读取都是异步的，不会阻塞线程，所以称为非阻塞型IO，在高并发的环境下性能很好。</p>
<p>IO 类设计出来，肯定是为了解决 IO 相关的操作的，想一想哪里会有 IO 操作？网络、磁盘。网络操作相关的类是在 java.net 包下，不在本文的总结范围内。提到磁盘，你可能会想到文件，文件操作在 IO 中是比较典型的操作。在 Java 中引入了 “流” 的概念，它表示任何有能力产生数据源或有能力接收数据源的对象。数据源可以想象成水源，海水、河水、湖水、一杯水等等。数据传输可以想象为水的运输，古代有用桶运水，用竹管运水的，现在有钢管运水，不同的运输方式对应不同的运输特性。</p>
<p>从数据来源或者说是操作对象角度看，IO 类可以分为：</p>
<p>1、<strong>文件（file）</strong>：FileInputStream、FileOutputStream、FileReader、FileWriter<br>2、<strong>数组（[]）</strong>：<br>2.1、字节数组（byte[]）：ByteArrayInputStream、ByteArrayOutputStream<br>2.2、字符数组（char[]）：CharArrayReader、CharArrayWriter<br>3、<strong>管道操作</strong>：PipedInputStream、PipedOutputStream、PipedReader、PipedWriter<br>4、<strong>基本数据类型</strong>：DataInputStream、DataOutputStream<br>5、<strong>缓冲操作</strong>：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter<br>6、<strong>打印</strong>：PrintStream、PrintWriter<br>7、<strong>对象序列化反序列化</strong>：ObjectInputStream、ObjectOutputStream<br>8、<strong>转换</strong>：InputStreamReader、OutputStreWriter<br>9、<del>字符串（String）Java8中已废弃：StringBufferInputStream、StringBufferOutputStream、StringReader、StringWriter</del><br>数据源节点也可以再进行二次处理，使数据更加容易使用，所以还可以划分成节点流和处理流<br><img src="https://img-blog.csdnimg.cn/20200608133604231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>从数据传输方式或者说是运输方式角度看，可以将 IO 类分为：</strong></p>
<ul>
<li>1、字节流</li>
<li>2、字符流</li>
</ul>
<p>字节流是以<strong>一个字节单位</strong>来运输的，比如一杯一杯的取水。而字符流是以<strong>多个字节</strong>来运输的，比如一桶一桶的取水，一桶水又可以分为几杯水。</p>
<p>字节流和字符流的区别：</p>
<p>字节流读取单个字节，字符流读取单个字符（一个字符根据编码的不同，对应的字节也不同，如 UTF-8 编码是 3 个字节，中文编码是 2 个字节。）字节流用来<strong>处理二进制文件</strong>（图片、MP3、视频文件），字符流用来处理<strong>文本文件</strong>（可以看做是特殊的二进制文件，使用了某种编码，人可以阅读）。简而言之，字节是个计算机看的，字符才是给人看的。</p>
<p>字节流和字符流的划分可以看下面这张图。<br><img src="https://img-blog.csdnimg.cn/20200608134713173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200608133738275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">不可否认，Java IO 相关的类确实很多，但我们并不是所有的类都会用到，我们常用的也就是文件相关的几个类，如文件最基本的读写类 File 开头的、文件读写带缓冲区的类 Buffered 开头的类，对象序列化反序列化相关的类 Object 开头的类。</p>
<h2 id="IO类和相关方法"><a href="#IO类和相关方法" class="headerlink" title="IO类和相关方法"></a>IO类和相关方法</h2><p>IO 类虽然很多，但最基本的是 4 个抽象类：<code>InputStream、OutputStream、Reader、Writer</code>。最基本的方法也就是一个读 read() 方法、一个写 write() 方法。方法具体的实现还是要看继承这 4 个抽象类的子类，毕竟我们平时使用的也是子类对象。这些类中的一些方法都是（Native）本地方法、所以并没有 Java 源代码，按照上面这个思路看，先看子类基本方法，然后在看看子类中还新增了那些方法，</p>
<p>先来看 InputStream 和 OutStream 中的方法简介，因为都是抽象类、大都是抽象方法、注意这里的读取和写入，其实就是获取（输入）数据和输出数据。</p>
<h3 id="InputStream-类"><a href="#InputStream-类" class="headerlink" title="InputStream 类"></a>InputStream 类</h3><p>方法介绍</p>
<pre><code class="java">public abstract int read()    读取数据
public int read(byte b[])    将读取到的数据放在 byte 数组中，该方法实际上是根据下面的方法实现的，off 为 0，len 为数组的长度
public int read(byte b[], int off, int len)    从第 off 位置读取 len 长度字节的数据放到 byte 数组中，流是以 -1 来判断是否读取结束的（注意这里读取的虽然是一个字节，但是返回的却是 int 类型 4 个字节，这里当然是有原因，这里就不再细说了，推荐这篇文章，链接）
public long skip(long n)    跳过指定个数的字节不读取，想想看电影跳过片头片尾
public int available()    返回可读的字节数量
public void close()    读取完，关闭流，释放资源
public synchronized void mark(int readlimit)    标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 markSupport() 方法判断
public synchronized void reset()    重置读取位置为上次 mark 标记的位置
public boolean markSupported()    判断当前流是否支持标记流，和上面两个方法配套使用
</code></pre>
<h3 id="OutputStream-类"><a href="#OutputStream-类" class="headerlink" title="OutputStream 类"></a>OutputStream 类</h3><p>方法介绍</p>
<pre><code class="java">public abstract void write(int b)    写入一个字节，可以看到这里的参数是一个 int 类型，对应上面的读方法，int 类型的 32 位，只有低 8 位才写入，高 24 位将舍弃。
public void write(byte b[])    将数组中的所有字节写入，和上面对应的 read() 方法类似，实际调用的也是下面的方法。
public void write(byte b[], int off, int len)    将 byte 数组从 off 位置开始，len 长度的字节写入
public void flush()    强制刷新，将缓冲中的数据写入
public void close()    关闭输出流，流被关闭后就不能再输出数据了
</code></pre>
<h3 id="Reader-类"><a href="#Reader-类" class="headerlink" title="Reader 类"></a>Reader 类</h3><p>方法介绍</p>
<pre><code class="java">public int read(java.nio.CharBuffer target)    读取字节到字符缓存中
public int read()    读取单个字符
public int read(char cbuf[])    读取字符到指定的 char 数组中
abstract public int read(char cbuf[], int off, int len)    从 off 位置读取 len 长度的字符到 char 数组中
public long skip(long n)    跳过指定长度的字符数量
public boolean ready()    和上面的 available() 方法类似
public boolean markSupported()    判断当前流是否支持标记流
public void mark(int readAheadLimit)    标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 markSupport() 方法判断
public void reset()    重置读取位置为上次 mark 标记的位置
abstract public void close()    关闭流释放相关资源
</code></pre>
<h3 id="Writer-类"><a href="#Writer-类" class="headerlink" title="Writer 类"></a>Writer 类</h3><p>方法介绍</p>
<pre><code class="java">public void write(int c)    写入一个字符
public void write(char cbuf[])    写入一个字符数组
abstract public void write(char cbuf[], int off, int len)    从字符数组的 off 位置写入 len 数量的字符
public void write(String str)    写入一个字符串
public void write(String str, int off, int len)    从字符串的 off 位置写入 len 数量的字符
public Writer append(CharSequence csq)    追加吸入一个字符序列
public Writer append(CharSequence csq, int start, int end)    追加写入一个字符序列的一部分，从 start 位置开始，end 位置结束
public Writer append(char c)    追加写入一个 16 位的字符
abstract public void flush()    强制刷新，将缓冲中的数据写入
abstract public void close()    关闭输出流，流被关闭后就不能再输出数据了
</code></pre>
<p>下面我们就直接使用他们的子类，在使用中再介绍下面没有的新方法。</p>
<p>读取控制台中的输入</p>
<pre><code class="java">import java.io.*;

public class IOTest &#123;
    public static void main(String[] args) throws IOException &#123;
        // 三个测试方法
//        test01();
//        test02();
        test03();
    &#125;

    public static void test01() throws IOException &#123;
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        System.out.println(&quot;请输入一个字符&quot;);
        char c;
        c = (char) bufferedReader.read();
        System.out.println(&quot;你输入的字符为&quot;+c);
    &#125;

    public static void test02() throws IOException &#123;
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        System.out.println(&quot;请输入一个字符，按 q 键结束&quot;);
        char c;
        do &#123;
            c = (char) bufferedReader.read();
            System.out.println(&quot;你输入的字符为&quot;+c);
        &#125; while (c != &#39;q&#39;);
    &#125;

    public static void test03() throws IOException &#123;
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        System.out.println(&quot;请输入一行字符&quot;);
        String str = bufferedReader.readLine();
        System.out.println(&quot;你输入的字符为&quot; + str);
    &#125;
&#125;
</code></pre>
<p>至于控制台的输出，我们其实一直都在使用呢，System.out.println() ，out 其实是 PrintStream 类对象的引用，PrintStream 类中当然也有 write() 方法，但是我们更常用 print() 方法和 println() 方法，因为这两个方法可以输出的内容种类更多，比如一个打印一个对象，实际调用的对象的 toString() 方法。</p>
<p>二进制文件的写入和读取</p>
<pre><code class="java">注意这里文件的路径，可以根据自己情况改一下，虽然这里的文件后缀是txt，但该文件却是一个二进制文件，并不能直接查看。

@Test
    public void test04() throws IOException &#123;
        byte[] bytes = &#123;12,21,34,11,21&#125;;
        FileOutputStream fileOutputStream = new FileOutputStream(new File(&quot;&quot;).getAbsolutePath()+&quot;/io/test.txt&quot;);
        // 写入二进制文件，直接打开会出现乱码
        fileOutputStream.write(bytes);
        fileOutputStream.close();
    &#125;

    @Test
    public void test05() throws IOException &#123;
        FileInputStream fileInputStream = new FileInputStream(new File(&quot;&quot;).getAbsolutePath()+&quot;/io/test.txt&quot;);
        int c;
        // 读取写入的二进制文件，输出字节数组
        while ((c = fileInputStream.read()) != -1) &#123;
            System.out.print(c);
        &#125;
    &#125;
</code></pre>
<p>文本文件的写入和读取</p>
<pre><code class="java">write() 方法和 append() 方法并不是像方法名那样，一个是覆盖内容，一个是追加内容，append() 内部也是 write() 方法实现的，也非说区别，也就是 append() 方法可以直接写 null，而 write() 方法需要把 null 当成一个字符串写入，所以两者并无本质的区别。需要注意的是这里并没有指定文件编码，可能会出现乱码的问题。

@Test
    public void test06() throws IOException &#123;
        FileWriter fileWriter = new FileWriter(new File(&quot;&quot;).getAbsolutePath()+&quot;/io/test.txt&quot;);
        fileWriter.write(&quot;Hello，world！\n欢迎来到 java 世界\n&quot;);
        fileWriter.write(&quot;不会覆盖文件原本的内容\n&quot;);
//        fileWriter.write(null); 不能直接写入 null
        fileWriter.append(&quot;并不是追加一行内容，不要被方法名迷惑\n&quot;);
        fileWriter.append(null);
        fileWriter.flush();
        System.out.println(&quot;文件的默认编码为&quot; + fileWriter.getEncoding());
        fileWriter.close();
    &#125;

    @Test
    public void test07() throws IOException &#123;
        FileWriter fileWriter = new FileWriter(new File(&quot;&quot;).getAbsolutePath()+&quot;/io/test.txt&quot;, false); // 关闭追加模式，变为覆盖模式
        fileWriter.write(&quot;Hello，world！欢迎来到 java 世界\n&quot;);
        fileWriter.write(&quot;我来覆盖文件原本的内容&quot;);
        fileWriter.append(&quot;我是下一行&quot;);
        fileWriter.flush();
        System.out.println(&quot;文件的默认编码为&quot; + fileWriter.getEncoding());
        fileWriter.close();
    &#125;

    @Test
    public void test08() throws IOException &#123;
        FileReader fileReader = new FileReader(new File(&quot;&quot;).getAbsolutePath()+&quot;/io/test.txt&quot;);
        BufferedReader bufferedReader = new BufferedReader(fileReader);
        String str;
        while ((str = bufferedReader.readLine()) != null) &#123;
            System.out.println(str);
        &#125;
        fileReader.close();
        bufferedReader.close();
    &#125;

    @Test
    public void test09() throws IOException &#123;
        FileReader fileReader = new FileReader(new File(&quot;&quot;).getAbsolutePath()+&quot;/io/test.txt&quot;);
        int c;
        while ((c = fileReader.read()) != -1) &#123;
            System.out.print((char) c);
        &#125;
    &#125;
使用字节流和字符流的转换类 InputStreamReader 和 OutputStreamWriter 可以指定文件的编码，使用 Buffer 相关的类来读取文件的每一行。

@Test
    public void test10() throws IOException &#123;
        FileOutputStream fileOutputStream = new FileOutputStream(new File(&quot;&quot;).getAbsolutePath()+&quot;/io/test2.txt&quot;);
        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream, &quot;GBK&quot;); // 使用 GBK 编码文件
        outputStreamWriter.write(&quot;Hello，world！\n欢迎来到 java 世界\n&quot;);
        outputStreamWriter.append(&quot;另外一行内容&quot;);
        outputStreamWriter.flush();
        System.out.println(&quot;文件的编码为&quot; + outputStreamWriter.getEncoding());
        outputStreamWriter.close();
        fileOutputStream.close();
    &#125;

    @Test
    public void test11() throws IOException &#123;
        FileInputStream fileInputStream = new FileInputStream(new File(&quot;&quot;).getAbsolutePath()+&quot;/io/test2.txt&quot;);
        InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream, &quot;GBK&quot;); // 使用 GBK 解码文件
        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
        String str;
        while ((str = bufferedReader.readLine()) != null) &#123;
            System.out.println(str);
        &#125;
        bufferedReader.close();
        inputStreamReader.close();
    &#125;
</code></pre>
<p>复制文件</p>
<pre><code class="java">@Test
    public void  test12() throws IOException &#123;
        // 输入和输出都使用缓冲流
        FileInputStream in = new FileInputStream(&quot;E:\\视频资料\\大数据原理与应用\\1.1大数据时代.mp4&quot;);
        BufferedInputStream inBuffer = new BufferedInputStream(in);
        FileOutputStream out = new FileOutputStream(&quot;1.1大数据时代.mp4&quot;);
        BufferedOutputStream outBuffer = new BufferedOutputStream(out);
        int len = 0;
        byte[] bs = new byte[1024];
        long begin = System.currentTimeMillis();
        while ((len = inBuffer.read(bs)) != -1) &#123;
            outBuffer.write(bs, 0, len);
        &#125;
        System.out.println(&quot;复制文件所需的时间：&quot; + (System.currentTimeMillis() - begin)); // 平均时间约 200 多毫秒
        inBuffer.close();
        in.close();
        outBuffer.close();
        out.close();
    &#125;


    @Test
    public void  test13() throws IOException &#123;
        // 只有输入使用缓冲流
        FileInputStream in = new FileInputStream(&quot;E:\\视频资料\\大数据原理与应用\\1.1大数据时代.mp4&quot;);
        BufferedInputStream inBuffer = new BufferedInputStream(in);
        FileOutputStream out = new FileOutputStream(&quot;1.1大数据时代.mp4&quot;);
        int len = 0;
        byte[] bs = new byte[1024];
        long begin = System.currentTimeMillis();
        while ((len = inBuffer.read(bs)) != -1) &#123;
            out.write(bs, 0, len);
        &#125;
        System.out.println(&quot;复制文件所需时间：&quot; + (System.currentTimeMillis() - begin)); // 平均时间约 500 多毫秒
        inBuffer.close();
        in.close();
        out.close();
    &#125;

    @Test
    public void test14() throws IOException &#123;
        // 输入和输出都不使用缓冲流
        FileInputStream in = new FileInputStream(&quot;E:\\视频资料\\大数据原理与应用\\1.1大数据时代.mp4&quot;);
        FileOutputStream out = new FileOutputStream(&quot;1.1大数据时代.mp4&quot;);
        int len = 0;
        byte[] bs = new byte[1024];
        long begin = System.currentTimeMillis();
        while ((len = in.read(bs)) != -1) &#123;
            out.write(bs, 0, len);
        &#125;
        System.out.println(&quot;复制文件所需时间：&quot; + (System.currentTimeMillis() - begin)); // 平均时间 700 多毫秒
        in.close();
        out.close();
    &#125;

    @Test
    public void test15() throws IOException &#123;
        // 不使用缓冲
        FileInputStream in = new FileInputStream(&quot;E:\\视频资料\\大数据原理与应用\\1.1大数据时代.mp4&quot;);
        FileOutputStream out = new FileOutputStream(&quot;1.1大数据时代.mp4&quot;);
        int len = 0;
        long begin = System.currentTimeMillis();
        while ((len = in.read()) != -1) &#123;
            out.write(len);
        &#125;
        System.out.println(&quot;复制文件所需时间：&quot; + (System.currentTimeMillis() - begin)); // 平均时间约 160000 毫秒，约 2 分多钟
        in.close();
        out.close();
    &#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/715659e4775f">链接简书</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-14%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/" rel="prev" title="每日一题@14只出现一次的数字">
      <i class="fa fa-chevron-left"></i> 每日一题@14只出现一次的数字
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/08/Hadoop-Yarn/" rel="next" title="Hadoop Yarn">
      Hadoop Yarn <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E4%BD%93%E7%B3%BB"><span class="nav-number">1.</span> <span class="nav-text">IO体系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E7%B1%BB%E5%92%8C%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">IO类和相关方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InputStream-%E7%B1%BB"><span class="nav-number">2.1.</span> <span class="nav-text">InputStream 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OutputStream-%E7%B1%BB"><span class="nav-number">2.2.</span> <span class="nav-text">OutputStream 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reader-%E7%B1%BB"><span class="nav-number">2.3.</span> <span class="nav-text">Reader 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Writer-%E7%B1%BB"><span class="nav-number">2.4.</span> <span class="nav-text">Writer 类</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="imarktsh"
      src="https://img-blog.csdnimg.cn/2020053010414625.jpg">
  <p class="site-author-name" itemprop="name">imarktsh</p>
  <div class="site-description" itemprop="description">明天一定学</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">146</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">imarktsh</span>
</div>

    <!-- 网站运行时间的设置 -->
    <span id="timeDate">载入天数...</span>
    <span id="times">载入时分秒...</span>  | It is building your life.
    <script>
        var now = new Date();
        function createtime() {
            var grt= new Date("01/05/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
            now.setTime(now.getTime()+250);
            days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
            hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
            if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
            mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
            seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
            snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
            document.getElementById("timeDate").innerHTML = "已运行 "+dnum+" 天 ";
            document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
    setInterval("createtime()",250);
    </script><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>
