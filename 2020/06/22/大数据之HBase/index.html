<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/128128.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/3232.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/1616.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"onlyear.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="入门HBase太长了，俺都不想偷，直接看别人链接 作者：Real_man链接：简书">
<meta property="og:type" content="article">
<meta property="og:title" content="大数据之HBase">
<meta property="og:url" content="http://onlyear.com/2020/06/22/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B9%8BHBase/index.html">
<meta property="og:site_name" content="imarktsh的博客">
<meta property="og:description" content="入门HBase太长了，俺都不想偷，直接看别人链接 作者：Real_man链接：简书">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200617114600780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200617114649311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200617115140723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200617115152113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200622104902183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2020-06-22T03:05:00.000Z">
<meta property="article:modified_time" content="2020-06-22T03:05:32.000Z">
<meta property="article:author" content="imarktsh">
<meta property="article:tag" content="大数据">
<meta property="article:tag" content="HBase">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200617114600780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70">

<link rel="canonical" href="http://onlyear.com/2020/06/22/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B9%8BHBase/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>大数据之HBase | imarktsh的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">imarktsh的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">多沉淀 多复盘</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://onlyear.com/2020/06/22/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B9%8BHBase/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://img-blog.csdnimg.cn/2020053010414625.jpg">
      <meta itemprop="name" content="imarktsh">
      <meta itemprop="description" content="明天一定学">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imarktsh的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          大数据之HBase
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-22 11:05:00 / 修改时间：11:05:32" itemprop="dateCreated datePublished" datetime="2020-06-22T11:05:00+08:00">2020-06-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="入门HBase"><a href="#入门HBase" class="headerlink" title="入门HBase"></a>入门HBase</h1><p>太长了，俺都不想偷，直接看别人链接</p>
<p><strong>作者：Real_man<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b23800d9b227">链接：简书</a></strong></p>
<span id="more"></span>


<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>Hbase是一种NoSQL数据库，这意味着它不像传统的RDBMS数据库那样支持SQL作为查询语言。Hbase是一种分布式存储的数据库，技术上来讲，它更像是分布式存储而不是分布式数据库，它缺少很多RDBMS系统的特性，比如列类型，辅助索引，触发器，和高级查询语言等待。<br><strong>那Hbase有什么特性呢？如下：</strong></p>
<ul>
<li>强读写一致，但是不是“最终一致性”的数据存储，这使得它非常适合高速的计算聚合</li>
<li>自动分片，通过Region分散在集群中，当行数增长的时候，Region也会自动的切分和再分配</li>
<li>自动的故障转移</li>
<li>Hadoop/HDFS集成，和HDFS开箱即用，不用太麻烦的衔接 丰富的“简洁，高效”API，Thrift/REST API，Java<br>API</li>
<li>块缓存，布隆过滤器，可以高效的列查询优化</li>
<li>操作管理，Hbase提供了内置的web界面来操作，还可以监控JMX指标</li>
</ul>
<h3 id="什么时候用Hbase？"><a href="#什么时候用Hbase？" class="headerlink" title="什么时候用Hbase？"></a>什么时候用Hbase？</h3><p><strong>Hbase不适合解决所有的问题：</strong></p>
<ul>
<li>首先数据库量要足够多，如果有十亿及百亿行数据，那么Hbase是一个很好的选项，如果只有几百万行甚至不到的数据量，RDBMS是一个很好的选择。因为数据量小的话，真正能工作的机器量少，剩余的机器都处于空闲的状态</li>
<li>其次，如果你不需要辅助索引，静态类型的列，事务等特性，一个已经用RDBMS的系统想要切换到Hbase，则需要重新设计系统。</li>
<li>最后，保证硬件资源足够，每个HDFS集群在少于5个节点的时候，都不能表现的很好。因为HDFS默认的复制数量是3，再加上一个NameNode。</li>
</ul>
<p>Hbase在单机环境也能运行，但是请在开发环境的时候使用。</p>
<h3 id="内部应用"><a href="#内部应用" class="headerlink" title="内部应用"></a>内部应用</h3><ul>
<li>存储业务数据:车辆GPS信息，司机点位信息，用户操作信息，设备访问信息。。。</li>
<li>存储日志数据:架构监控数据（登录日志，中间件访问日志，推送日志，短信邮件发送记录。。。），业务操作日志信息</li>
<li>存储业务附件：UDFS系统存储图像，视频，文档等附件信息 不过在公司使用的时候，一般不使用原生的Hbase<br>API，使用原生的API会导致访问不可监控，影响系统稳定性，以致于版本升级的不可控。</li>
</ul>
<h2 id="Hbase架构"><a href="#Hbase架构" class="headerlink" title="Hbase架构"></a>Hbase架构</h2><p><img src="https://img-blog.csdnimg.cn/20200617114600780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Zookeeper，作为分布式的协调。RegionServer也会把自己的信息写到ZooKeeper中。</li>
<li>HDFS是Hbase运行的底层文件系统</li>
<li>RegionServer，理解为数据节点，存储数据的。</li>
<li>Master RegionServer要实时的向Master报告信息。Master知道全局的RegionServer运行情况，可以控制RegionServer的故障转移和Region的切分。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200617114649311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>HMaster是Master<br>Server的实现，负责监控集群中的RegionServer实例，同时是所有metadata改变的接口，在集群中，通常运行在NameNode上面，这里有一篇更细的HMaster介绍</li>
<li>HMasterInterface暴露的接口，Table(createTable, modifyTable, removeTable,<br>enable, disable),ColumnFamily (addColumn, modifyColumn,<br>removeColumn),Region (move, assign, unassign)<br>Master运行的后台线程：LoadBalancer线程，控制region来平衡集群的负载。CatalogJanitor线程，周期性的检查hbase:meta表。</li>
<li>HRegionServer是RegionServer的实现，服务和管理Regions，集群中RegionServer运行在DataNode</li>
<li>HRegionRegionInterface暴露接口：Data (get, put, delete, next, etc.)，Region<br>(splitRegion, compactRegion, etc.)</li>
<li>RegionServer后台线程：CompactSplitThread，MajorCompactionChecker，MemStoreFlusher，LogRoller<br>Regions，代表table，Region有多个Store(列簇)，Store有一个Memstore和多个StoreFiles(HFiles)，StoreFiles的底层是Block。</li>
</ul>
<h2 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a>存储设计</h2><p>在Hbase中，表被分割成多个更小的块然后分散的存储在不同的服务器上，这些小块叫做<code>Regions</code>，存放Regions的地方叫做<code>RegionServer</code>。Master进程负责处理不同的RegionServer之间的Region的分发。在Hbase实现中HRegionServer和HRegion类代表RegionServer和Region。HRegionServer除了包含一些HRegions之外，还处理两种类型的文件用于数据存储</p>
<ul>
<li>HLog， 预写日志文件，也叫做WAL(write-ahead log)</li>
<li>HFile 真实的数据存储文件</li>
</ul>
<h3 id="HLog"><a href="#HLog" class="headerlink" title="HLog"></a>HLog</h3><ul>
<li>MasterProcWAL：HMaster记录管理操作，比如解决冲突的服务器，表创建和其它DDLs等操作到它的WAL文件中，这个WALs存储在MasterProcWALs目录下，它不像RegionServer的WALs，HMaster的WAL也支持弹性操作，就是如果Master服务器挂了，其它的Master接管的时候继续操作这个文件。</li>
<li>WAL记录所有的Hbase数据改变，如果一个RegionServer在MemStore进行FLush的时候挂掉了，WAL可以保证数据的改变被应用到。如果写WAL失败了，那么修改数据的完整操作就是失败的。</li>
<li>通常情况，每个RegionServer只有一个WAL实例。在2.0之前，WAL的实现叫做HLog</li>
<li>WAL位于/hbase/WALs/目录下</li>
<li>MultiWAL: 如果每个RegionServer只有一个WAL，由于HDFS必须是连续的，导致必须写WAL连续的，然后出现性能问题。MultiWAL可以让RegionServer同时写多个WAL并行的，通过HDFS底层的多管道，最终提升总的吞吐量，但是不会提升单个Region的吞吐量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  WAL的配置：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用multiwal</span></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hbase.wal.provider&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;multiwal&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>


<h3 id="HFile"><a href="#HFile" class="headerlink" title="HFile"></a>HFile</h3><p>HFile是Hbase在HDFS中存储数据的格式，它包含多层的索引，这样在Hbase检索数据的时候就不用完全的加载整个文件。索引的大小(keys的大小，数据量的大小)影响block的大小，在大数据集的情况下，block的大小设置为每个RegionServer 1GB也是常见的。</p>
<p>探讨数据库的数据存储方式，其实就是探讨数据如何在磁盘上进行有效的组织。因为我们通常以如何高效读取和消费数据为目的，而不是数据存储本身。</p>
<p><strong>Hfile生成方式</strong><br>起初，HFile中并没有任何Block，数据还存在于MemStore中。</p>
<p>Flush发生时，创建HFile Writer，第一个空的Data Block出现，初始化后的Data Block中为Header部分预留了空间，Header部分用来存放一个Data Block的元数据信息。</p>
<p>而后，位于MemStore中的KeyValues被一个个append到位于内存中的第一个Data Block中：</p>
<p><strong>注：</strong>如果配置了Data Block Encoding，则会在Append KeyValue的时候进行同步编码，编码后的数据不再是单纯的KeyValue模式。Data Block Encoding是HBase为了降低KeyValue结构性膨胀而提供的内部编码机制。<br><img src="https://img-blog.csdnimg.cn/20200617115140723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200617115152113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Hbase单机模式安装"><a href="#Hbase单机模式安装" class="headerlink" title="Hbase单机模式安装"></a>Hbase单机模式安装</h2><p>这一次来部署一个单机版的Hbase，单独的Hbase daemon(Master，RegionServers和ZooKeeper)运行在同一个JVM进程中，然后持久化存储到文件系统中。这是最简单的部署，但是却能帮助我们更好的理解Hbase。安装完成之后，我们在演示一下hbase命令行的用法。<br>这个安装搞了两天失败了 这个留着回学校部署；</p>
<h2 id="使用Hbase"><a href="#使用Hbase" class="headerlink" title="使用Hbase"></a>使用Hbase</h2><p>我们可以先用Hbase提供的命令行工具，位于hbase的/bin/目录下</p>
<p>连接Hbase</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="operator">/</span>hbase shell</span><br></pre></td></tr></table></figure>

<p>查看帮助信息, 敲</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span>help</span><br></pre></td></tr></table></figure>
<p>创建一个表，必须要指定表名称和列簇名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):<span class="number">003</span>:<span class="number">0</span><span class="operator">&gt;</span> <span class="keyword">create</span> <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;cf&#x27;</span></span><br><span class="line"><span class="number">0</span> <span class="type">row</span>(s) <span class="keyword">in</span> <span class="number">1.6320</span> seconds</span><br><span class="line"></span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> Hbase::<span class="keyword">Table</span> <span class="operator">-</span> test</span><br></pre></td></tr></table></figure>

<h2 id="Hbase数据模型"><a href="#Hbase数据模型" class="headerlink" title="Hbase数据模型"></a>Hbase数据模型</h2><p>在Hbase中，有一些术语需要提前了解。如下：</p>
<ul>
<li>Table：Hbase的table由多个行组成</li>
<li>Row：一个行在Hbase中由一个或多个有值的列组成。Row按照字母进行排序，因此行健的设计非常重要。这种设计方式可以让有关系的行非常的近，通常行健的设计是网站的域名反转，比如(org.apache.www,<br>org.apache.mail, org.apache.jira)，这样的话所有的Apache的域名就很接近。</li>
<li>Column：列由列簇加上列的标识组成，一般是“列簇：列标识”，创建表的时候不用指定列标识</li>
<li>Column<br>Family：列簇在物理上包含了许多的列与列的值，每个列簇都有一些存储的属性可配置。例如是否使用缓存，压缩类型，存储版本数等。在表中，每一行都有相同的列簇，尽管有些列簇什么东西也没有存。</li>
<li>Column Qualifier：列簇的限定词，理解为列的唯一标识。但是列标识是可以改变的，因此每一行可能有不同的列标识</li>
<li>Cell：Cell是由row，column family,column qualifier包含时间戳与值组成的，一般表达某个值的版本</li>
<li>Timestamp：时间戳一般写在value的旁边，代表某个值的版本号，默认的时间戳是你写入数据的那一刻，但是你也可以在写入数据的时候指定不同的时间戳</li>
<li>HBase 是一个稀疏的、分布式、持久、多维、排序的映射，它以行键（row key），列键（column key）和时间戳（timestamp）为索引。</li>
</ul>
<p> Hbase在存储数据的时候，有两个SortedMap，首先按照rowkey进行字典排序，然后再对Column进行字典排序。<img src="https://img-blog.csdnimg.cn/20200622104902183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Hbase表-Schema-设计要点"><a href="#Hbase表-Schema-设计要点" class="headerlink" title="Hbase表(Schema)设计要点"></a>Hbase表(Schema)设计要点</h2><p>只要是数据库都存在，模式设计的问题，关系型中有模式设计的范式，Hbase作为列式存储数据库，其模式设计也非常重要。</p>
<p>设计时需要关注的属性，如何设计这些属性等</p>
<p>Hbase与关系型数据库对比</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">属性	      Hbase  	RDBMS</span><br><span class="line">数据类型	只有字符串	丰富的数据类型</span><br><span class="line">数据操作	增删改查，不支持<span class="keyword">join</span>	各种各样的函数与表连接</span><br><span class="line">存储模式	基于列式存储	基于表结构和行式存储</span><br><span class="line">数据保护	更新后仍然保留旧版本	替换</span><br><span class="line">可伸缩性	轻易增加节点	需要中间层，牺牲性能</span><br></pre></td></tr></table></figure>

<h3 id="Hbase设计时要考虑的因素"><a href="#Hbase设计时要考虑的因素" class="headerlink" title="Hbase设计时要考虑的因素"></a>Hbase设计时要考虑的因素</h3><p>Hbase关键概念：表，rowkey，列簇，时间戳</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这个表应该有多少列簇</span><br><span class="line">列簇使用什么数据</span><br><span class="line">每个列簇有有多少列</span><br><span class="line">列名是什么，尽管列名不必在建表时定义，但读写数据是要知道的</span><br><span class="line">单元应该存放什么数据</span><br><span class="line">每个单元存储多少时间版本</span><br><span class="line">行健(rowKey)结构是什么，应该包含什么信息</span><br></pre></td></tr></table></figure>

<h2 id="设计要点"><a href="#设计要点" class="headerlink" title="设计要点"></a>设计要点</h2><h3 id="行健设计"><a href="#行健设计" class="headerlink" title="行健设计"></a>行健设计</h3><ul>
<li>关键部分，直接关系到后续服务的访问性能。如果行健设计不合理，后续查询服务效率会成倍的递减。</li>
<li>避免单调的递增行健，因为Hbase的行健是有序排列的，这样可能导致一段时间内大部分写入集中在某一个Region上进行操作，负载都在一台节点上。可以设计成：<br>[metric_type][event_timestamp]，不同的metric_type可以将压力分散到不同的region上</li>
<li>行健短到可读即可，因为查询短键不必长键性能好多少，所以设计时要权衡长度。</li>
<li>行健不能改变，唯一可以改变的方式是先删除后插入 </li>
</ul>
<h3 id="列簇设计"><a href="#列簇设计" class="headerlink" title="列簇设计"></a>列簇设计</h3><ul>
<li>列簇是一些列的集合，一个列簇的成员有相同的前缀，以冒号(:)作为分隔符。</li>
<li>现在Hbase不能很好处理2~3个以上的列簇，所以尽可能让列簇少一些，如果表有多个列簇，列簇A有100万行数据，列簇B有10亿行，那么列簇A会分散到很多的Region导致扫描列簇A的时候效率底下。</li>
<li>列簇名的长度要尽量小，一个为了节省空间，另外加快效率，比如d表示data，v表示value</li>
</ul>
<h3 id="列簇属性配置"><a href="#列簇属性配置" class="headerlink" title="列簇属性配置"></a>列簇属性配置</h3><p>HFile数据块，默认是64KB，数据库的大小影响数据块索引的大小。数据块大的话一次加载进内存的数据越多，扫描查询效果越好。但是数据块小的话，随机查询性能更好</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; create <span class="string">&#x27;mytable&#x27;</span>,&#123;NAME =&gt; <span class="string">&#x27;cf1&#x27;</span>, BLOCKSIZE =&gt; <span class="string">&#x27;65536&#x27;</span>&#125;</span><br><span class="line">数据块缓存，数据块缓存默认是打开的，如果一些比较少访问的数据可以选择关闭缓存</span><br><span class="line">&gt; create <span class="string">&#x27;mytable&#x27;</span>,&#123;NAME =&gt; <span class="string">&#x27;cf1&#x27;</span>, BLOCKCACHE =&gt; <span class="string">&#x27;FALSE&#x27;</span>&#125;</span><br><span class="line">数据压缩，压缩会提高磁盘利用率，但是会增加CPU的负载，看情况进行控制</span><br><span class="line">&gt; create <span class="string">&#x27;mytable&#x27;</span>,&#123;NAME =&gt; <span class="string">&#x27;cf1&#x27;</span>, COMPRESSION =&gt; <span class="string">&#x27;SNAPPY&#x27;</span>&#125;</span><br><span class="line">Hbase表设计是和需求相关的，但是遵守表设计的一些硬性指标对性能的提升还是很有帮助的，这里整理了一些设计时用到的要点。</span><br></pre></td></tr></table></figure>

<h2 id="Java-API操作"><a href="#Java-API操作" class="headerlink" title="Java API操作"></a>Java API操作</h2><p>Hbase有多种不同的客户端，如REST客户端，Thift客户端，ORM框架Kundera等等。 Hbase也提供了Java的API来操作表与列簇等信息，它的shell就是对Java的API做了一层封装。</p>
<p>Hbase的Java API提供了很多高级的特性：</p>
<ul>
<li>元数据管理，列簇的数据压缩，region分隔</li>
<li>创建，删除，更新，读取 rowkey</li>
</ul>
<p>我们还是直接看代码这样理解的更容易</p>
<p>环境<br>Hbase 0.98<br>Java 1.8<br>Zookeeper 3.4.6<br>Mac OS<br>案例<br>Hbase的客户端版本不一致实验结果很容易出现问题，尽量采用同样的版本。因为服务端实验的是Hbase0.98，客户端也用0.98，另外由于Hadoop 2.x的版本现对于1.x做了很大的提升，建议采用Hbase-hadoop 2.x的客户端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;hbase-client&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;<span class="number">0.98</span><span class="number">.24</span>-hadoop2&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>建立连接</strong></p>
<ol>
<li>直接新建HTable(“tableName”)，但是这种每次创建表的时候因为都要查询.meta表，来判断表是不是存在，导致创建表的过程会有点慢，所以不建议每个请求都创建一个Htable</li>
<li>使用HTablePool，它和HTable的创建方式很像，但是如果采用连接池的话，它就不会给每个请求都单独创建一个Htable了。</li>
</ol>
<p><strong>增删改查</strong><br>rowkey是代表Hbase中表的唯一一个行，同时像列簇 ，时间戳等用来定位表中的部分数据，Java的API对Hbas的CURD提供了如下的类：</p>
<p>Put<br>Get<br>Delete<br>Scan<br>Increment<br>我们详细的讨论几个类，剩余的可以举一反三。</p>
<p><strong>写数据</strong><br>当写请求收到的时候，默认数据同步的写到Hlog中和MemStore，同时在两个地方写是为了保证数据的持久性，Memstore最终会持久化到磁盘中的Hfile中。每次MemStore进行Flush的时候，就会创建一个新的Hfile。</p>
<p>Put类用于向Hbase的表中存储数据，存储数据时，Put的实例必须要指定Rowkey<br>创建完Put实例后，再向其中添加数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">// 获取默认的配置</span></span><br><span class="line">       Configuration conf = HBaseConfiguration.create();</span><br><span class="line">       <span class="comment">// 获取Table实例 </span></span><br><span class="line">       HTable table = <span class="keyword">new</span> HTable(conf, <span class="string">&quot;tab1&quot;</span>);</span><br><span class="line">       <span class="comment">// 创建Put实例，并且指定rowKey </span></span><br><span class="line">       Put put = <span class="keyword">new</span> Put(Bytes.toBytes(<span class="string">&quot;row-1&quot;</span>));</span><br><span class="line">       <span class="comment">// 添加一个 column，值为 &quot;Hello&quot;，在 &quot;cf1:greet&quot; 列中</span></span><br><span class="line">       put.add(Bytes.toBytes(<span class="string">&quot;cf1&quot;</span>), Bytes.toBytes(<span class="string">&quot;greet&quot;</span>), Bytes.toBytes(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">       <span class="comment">// 添加一个 column，值为 &quot;John&quot;，在 &quot;cf1:person&quot; 列中</span></span><br><span class="line">       put.add(Bytes.toBytes(<span class="string">&quot;cf1&quot;</span>), Bytes.toBytes(<span class="string">&quot;person&quot;</span>), Bytes.toBytes(<span class="string">&quot;John&quot;</span>));</span><br><span class="line">       table.put(put); </span><br><span class="line">       table.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>数据也可以批量的进行插入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// table对象可以传入List参数</span></span><br><span class="line">table.put(<span class="keyword">final</span> List&lt;Put&gt; puts)</span><br></pre></td></tr></table></figure>

<p><strong>读数据</strong><br>Hbase使用LRU缓存读取数据。Htable对象使用下面的方法读取数据</p>
<p>而Get实例的构造方法和Put很像，构造方法要指定一个rowkey。</p>
<p>如果要查找特定的cell，就是特定列的数据，可以采用额外的方法进行更加精细的调控。<br>看一下如下的案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取默认的配置</span></span><br><span class="line">        Configuration conf = HBaseConfiguration.create();</span><br><span class="line">        <span class="comment">// 获取Table实例</span></span><br><span class="line">        HTable table = <span class="keyword">new</span> HTable(conf, <span class="string">&quot;tab1&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建Put实例，并且指定rowKey</span></span><br><span class="line">        Get get = <span class="keyword">new</span> Get(Bytes.toBytes(<span class="string">&quot;row-1&quot;</span>));</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        get.addColumn(Bytes.toBytes(<span class="string">&quot;cf1&quot;</span>), Bytes.toBytes(<span class="string">&quot;greet&quot;</span>));</span><br><span class="line">        <span class="comment">// 添加一个 column，值为 &quot;John&quot;，在 &quot;cf1:person&quot; 列中</span></span><br><span class="line">        Result result = table.get(get);</span><br><span class="line">        <span class="keyword">byte</span>[] value = result.getValue(Bytes.toBytes(<span class="string">&quot;cf1&quot;</span>), Bytes.toBytes(<span class="string">&quot;greet&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;获取到的值&quot;</span> + <span class="keyword">new</span> String(value));</span><br><span class="line">        table.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p><strong>更新数据</strong><br>更新数据与写数据基本一致，只是在Put实例赋值的时候，在相同的列上设置不同的值，操作的时候就会更新为新的值。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Configuration conf = HBaseConfiguration.create();</span><br><span class="line">        <span class="comment">// 获取Table实例</span></span><br><span class="line">        HTable table = <span class="keyword">new</span> HTable(conf, <span class="string">&quot;tab1&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建Put实例，并且指定rowKey</span></span><br><span class="line">        Put put = <span class="keyword">new</span> Put(Bytes.toBytes(<span class="string">&quot;row-1&quot;</span>));</span><br><span class="line">        <span class="comment">// 添加一个 column，值为 &quot;Hello&quot;，在 &quot;cf1:greet&quot; 列中</span></span><br><span class="line">        put.add(Bytes.toBytes(<span class="string">&quot;cf1&quot;</span>), Bytes.toBytes(<span class="string">&quot;greet&quot;</span>), Bytes.toBytes(<span class="string">&quot;Good Morning&quot;</span>));</span><br><span class="line">        <span class="comment">// 添加一个 column，值为 &quot;John&quot;，在 &quot;cf1:person&quot; 列中</span></span><br><span class="line"><span class="comment">//        put.add(Bytes.toBytes(&quot;cf1&quot;), Bytes.toBytes(&quot;person&quot;), Bytes.toBytes(&quot;John&quot;));</span></span><br><span class="line">        table.put(put);</span><br><span class="line">        table.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除数据</strong><br>Delete命令只是标记当前的数据为删除状态，而不是立刻的删除，也就是先进行逻辑删除。实际上的删除是在Hfile进行压缩的时候，这些被标记的记录就会被删除掉。</p>
<p>Delete对象与Put和Get也很像</p>
<p>看下面的案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Configuration conf = HBaseConfiguration.create();</span><br><span class="line">        <span class="comment">// 获取Table实例</span></span><br><span class="line">        HTable table = <span class="keyword">new</span> HTable(conf, <span class="string">&quot;tab1&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建Delete实例，并且指定rowKey</span></span><br><span class="line">        Delete delete = <span class="keyword">new</span> Delete(Bytes.toBytes(<span class="string">&quot;row-1&quot;</span>));</span><br><span class="line">        <span class="comment">// 删除 column &quot;cf1:greet&quot; </span></span><br><span class="line">        delete.deleteColumn(Bytes.toBytes(<span class="string">&quot;cf1&quot;</span>), Bytes.toBytes(<span class="string">&quot;greet&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        table.delete(delete);</span><br><span class="line">        table.close();</span><br><span class="line">    &#125;</span><br><span class="line">执行结果:连续执行两次删除</span><br></pre></td></tr></table></figure>

<h2 id="操作优化"><a href="#操作优化" class="headerlink" title="操作优化"></a>操作优化</h2><p>一个系统上线之后，开发和调优将一直贯穿系统的生命周期中，HBase也不列外。这里主要说一些Hbase的调优</p>
<p><strong>Hbase查询优化</strong><br>作为NoSQL数据库，增删改查是其最基本的功能，其中查询是最常用的一项。</p>
<p><strong>设置Scan缓存</strong><br>HBase中Scan查询可以设置缓存，方法是setCaching()，这样可以有效的减少服务端与客户端的交互，更有效的提升扫描查询的性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the number of rows for caching that will be passed to scanners.</span></span><br><span class="line"><span class="comment"> * If not set, the default setting from &#123;<span class="doctag">@link</span> HTable#getScannerCaching()&#125; will apply.</span></span><br><span class="line"><span class="comment"> * Higher caching values will enable faster scanners but will use more memory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> caching the number of rows for caching</span></span><br><span class="line"><span class="comment"> * 设置scanners缓存的行数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCaching</span><span class="params">(<span class="keyword">int</span> caching)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.caching = caching;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>显示的指定列</strong><br>当使用Scan或者GET获取大量的行时，最好指定所需要的列，因为服务端通过网络传输到客户端，数据量太大可能是瓶颈。如果能有效过滤部分数据，能很大程度的减少网络I/O的花费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get all columns from the specified family.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * Overrides previous calls to addColumn for this family.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> family family name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">   * 获取指定列簇的所有列</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Scan <span class="title">addFamily</span><span class="params">(<span class="keyword">byte</span> [] family)</span> </span>&#123;</span><br><span class="line">    familyMap.remove(family);</span><br><span class="line">    familyMap.put(family, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the column from the specified family with the specified qualifier.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * Overrides previous calls to addFamily for this family.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> family family name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> qualifier column qualifier</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">   * 获取指定列簇的特定列</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Scan <span class="title">addColumn</span><span class="params">(<span class="keyword">byte</span> [] family, <span class="keyword">byte</span> [] qualifier)</span> </span>&#123;</span><br><span class="line">    NavigableSet&lt;<span class="keyword">byte</span> []&gt; set = familyMap.get(family);</span><br><span class="line">    <span class="keyword">if</span>(set == <span class="keyword">null</span>) &#123;</span><br><span class="line">      set = <span class="keyword">new</span> TreeSet&lt;<span class="keyword">byte</span> []&gt;(Bytes.BYTES_COMPARATOR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (qualifier == <span class="keyword">null</span>) &#123;</span><br><span class="line">      qualifier = HConstants.EMPTY_BYTE_ARRAY;</span><br><span class="line">    &#125;</span><br><span class="line">    set.add(qualifier);</span><br><span class="line">    familyMap.put(family, set);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">一般用:</span><br><span class="line">scan.addColumn(...)</span><br></pre></td></tr></table></figure>

<p><strong>关闭ResultScanner</strong><br>如果在使用table.getScanner之后，忘记关闭该类，它会一直和服务端保持连接，资源无法释放，从而导致服务端的某些资源不可用。</p>
<p>所以在用完之后，需要执行关闭操作，这点与JDBS操作MySQL类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanner.close()</span><br></pre></td></tr></table></figure>

<p><strong>禁用块缓存</strong><br>如果批量进行全表扫描，默认是有缓存的，如果此时有缓存，会降低扫描的效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan.setCacheBlocks(<span class="keyword">true</span>|<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>对于经常读到的数据，建议使用默认值，开启块缓存</p>
<p><strong>缓存查询结果</strong><br>对于频繁查询HBase的应用场景，可以考虑在应用程序和Hbase之间做一层缓存系统，新的查询先去缓存查，缓存没有再去查Hbase。</p>
<p><strong>写入优化</strong><br>写也是Hbase常有的操作之一，并且Hbase在写入操作上有着其他NoSQL无法比拟的优势，下面讲如何优化写入操作</p>
<p><strong>关闭写WAL日志</strong><br>一般为了保证系统的高可用性，WAL日志默认是开启状态，WAL主要用于灾难恢复的，如果应用可以容忍一定的数据丢失风险，可以在写数据的时候，关闭写WAL。</p>
<p>风险： 当RegionServer宕机时，写入的数据出现丢失，且无法恢复</p>
<p><strong>设置AutoFlush</strong><br>Htable有一个属性是AutoFlush，该属性用于支持客户端的批量更新，默认是true，当客户端每收到一条数据，立刻发送到服务端，如果设置为false，当客户端提交put请求时候，先将该请求在客户端缓存，到达阈值的时候或者执行hbase.flushcommits()，才向RegionServer提交请求。</p>
<p>风险 在请求未发送到RegionServer之前客户端崩溃，数据也会丢失</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">table.setAutoFlush(<span class="keyword">false</span>);</span><br><span class="line">table.setWriteBufferSize( <span class="number">12</span> * <span class="number">1024</span> * <span class="number">1024</span> );</span><br></pre></td></tr></table></figure>

<p><strong>预创建Region</strong><br>一般表刚开始只有一个Region，插入该表的数据都会保存在此Region中，插入该表的所有塑化剂都会保存在该Region中，当到达一定的阈值时，才发生分裂。 这样开始时刻针对该表的写操作都集中在某台服务器上，造成这台服务器的压力很紧张，同时对整个集群资源的浪费</p>
<p>建议刚开始的时候预创建Region，可以使用Hbase自带的RegionSplitter</p>
<p><strong>延迟日志flush</strong><br>默认写入操作，首先写入WAL，并且在1S内写入HDFS，这个时间默认是1S，可以通过参数配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase.regionserver.optionallogflushinterval</span><br></pre></td></tr></table></figure>

<p>可以配置大一点的值，比如5s，这段时间数据会保留在内存中，直到RegionServer周期性的执行flush操作。</p>
<p><strong>Scan的重要参数</strong><br>Scan是操作Hbase中非常常用的一个操作，虽然前面的Hbase API操作简单的介绍了Scan的操作，但不够详细，由于Scan非常常用，关于其详细的整理也是很有必要的。</p>
<p><strong>Scan</strong><br>HBase中的数据表通过划分成一个个的Region来实现数据的分片，每一个Region关联一个RowKey的范围区间，而每一个Region中的数据，按RowKey的字典顺序进行组织。</p>
<p>正是基于这种设计，使得HBase能够轻松应对这类查询：”指定一个RowKey的范围区间，获取该区间的所有记录”， 这类查询在HBase被称之为Scan。</p>
<p>1 . 构建Scan，指定startRow与stopRow，如果未指定的话会进行全表扫描<br>2 . 获取ResultScanner<br>3 . 遍历查询结果<br>4 . 关闭ResultScanner</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stringFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       Configuration conf = HBaseConfiguration.create();</span><br><span class="line">       <span class="comment">// 获取Table实例</span></span><br><span class="line">       HTable table = <span class="keyword">new</span> HTable(conf, <span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 构建Scan</span></span><br><span class="line">       Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">       scan = scan.setStartRow(Bytes.toBytes(<span class="string">&quot;startRowxxx&quot;</span>)).setStopRow(Bytes.toBytes(<span class="string">&quot;StopRowxxx&quot;</span>));</span><br><span class="line">       RowFilter filter = <span class="keyword">new</span> RowFilter(</span><br><span class="line">               CompareFilter.CompareOp.EQUAL,</span><br><span class="line">               <span class="keyword">new</span> BinaryComparator(Bytes.toBytes(<span class="string">&quot;224382618261914241&quot;</span>))</span><br><span class="line">       );</span><br><span class="line"></span><br><span class="line">       scan.setFilter(filter);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 获取resultScanner</span></span><br><span class="line">       ResultScanner scanner = table.getScanner(scan);</span><br><span class="line">       Result result = <span class="keyword">null</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 处理结果</span></span><br><span class="line">       <span class="keyword">while</span> ((result = scanner.next()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">byte</span>[] value = result.getValue(Bytes.toBytes(<span class="string">&quot;ship&quot;</span>), Bytes.toBytes(<span class="string">&quot;addr&quot;</span>));</span><br><span class="line">           <span class="keyword">if</span> (value == <span class="keyword">null</span> || value.length == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(</span><br><span class="line">                   <span class="keyword">new</span> String(value)</span><br><span class="line">           );</span><br><span class="line">           System.out.println(<span class="string">&quot;hello World&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="comment">// 关闭ResultScanner</span></span><br><span class="line">       scanner.close();</span><br><span class="line">       table.close();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>其它的设置参数</strong><br>Caching: 设置一次RPC请求批量读取的Results数量<br>下面的示例代码设定了一次读取回来的Results数量为100：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan.setCaching(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>Client每一次往RegionServer发送scan请求，都会批量拿回一批数据(由Caching决定过了每一次拿回的Results数量)，然后放到本次的Result Cache中：</p>
<p>应用每一次读取数据时，都是从本地的Result Cache中获取的。如果Result Cache中的数据读完了，则Client会再次往RegionServer发送scan请求获取更多的数据。</p>
<p>Batch: 设置每一个Result中的列的数量<br>下面的示例代码设定了每一个Result中的列的数量的限制值为3：</p>
<p>scan.setBatch(3);<br>该参数适用于一行数据过大的场景，这样，一行数据被请求的列会被拆成多个Results返回给Client。</p>
<p>举例说明如下：</p>
<p>假设一行数据中共有十个列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;Col01，Col02，Col03，Col04，Col05，Col06，Col07，Col08，Col09, Col10&#125;</span><br></pre></td></tr></table></figure>

<p>假设Scan中设置的Batch为3，那么，这一行数据将会被拆成4个Results返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Result1 -&gt; &#123;Col01，Col02，Col03&#125;</span><br><span class="line">Result2 -&gt; &#123;Col04，Col05，Col06&#125;</span><br><span class="line">Result3 -&gt; &#123;Col07，Col08，Col09&#125;</span><br><span class="line">Result4 -&gt; &#123;Col10&#125;</span><br></pre></td></tr></table></figure>

<p>关于Caching参数，我们说明了是Client每一次从RegionServer侧获取到的Results的数量，上例中，一行数据被拆成了4个Results，这将会导致Caching中的计数器被减了4次。结合Caching与Batch，我们再列举一个稍复杂的例子：</p>
<p>假设，Scan的参数设置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] start = Bytes.toBytes(<span class="string">&quot;Row1&quot;</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] stop = Bytes.toBytes(<span class="string">&quot;Row5&quot;</span>);</span><br><span class="line">Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">scan.withStartRow(start).withStopRow(stop);</span><br><span class="line">scan.setCaching(<span class="number">10</span>);</span><br><span class="line">scan.setBatch(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>待读取的数据RowKey与所关联的列集如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Row1: &#123;Col01，Col02，Col03，Col04，Col05，Col06，Col07，Col08，Col09，Col10&#125;</span><br><span class="line">Row2: &#123;Col01，Col02，Col03，Col04，Col05，Col06，Col07，Col08，Col09，Col10，Col11&#125;</span><br><span class="line">Row3: &#123;Col01，Col02，Col03，Col04，Col05，Col06，Col07，Col08，Col09，Col10&#125;</span><br></pre></td></tr></table></figure>

<p>再回顾一下Caching与Batch的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Caching: 影响一次读取返回的Results数量。</span><br><span class="line"></span><br><span class="line">Batch: 限定了一个Result中所包含的列的数量，如果一行数据被请求的列的数量超出Batch限制，那么这行数据会被拆成多个Results。</span><br><span class="line"></span><br><span class="line">那么， Client往RegionServer第一次请求所返回的结果集如下所示：</span><br><span class="line"></span><br><span class="line">Result1 -&gt; Row1: &#123;Col01，Col02，Col03&#125;</span><br><span class="line">Result2 -&gt; Row1: &#123;Col04，Col05，Col06&#125;</span><br><span class="line">Result3 -&gt; Row1: &#123;Col07，Col08，Col09&#125;</span><br><span class="line">Result4 -&gt; Row1: &#123;Col10&#125;</span><br><span class="line">Result5 -&gt; Row2: &#123;Col01，Col02，Col03&#125;</span><br><span class="line">Result6 -&gt; Row2: &#123;Col04，Col05，Col06&#125;</span><br><span class="line">Result7 -&gt; Row2: &#123;Col07，Col08，Col09&#125;</span><br><span class="line">Result8 -&gt; Row2: &#123;Col10，Col11&#125;</span><br><span class="line">Result9 -&gt; Row3: &#123;Col01，Col02，Col03&#125;</span><br><span class="line">Result10 -&gt; Row3: &#123;Col04，Col05，Col06&#125;</span><br></pre></td></tr></table></figure>

<p>Limit: 限制一次Scan操作所获取的行的数量<br>同SQL语法中的limit子句，限制一次Scan操作所获取的行的总量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan.setLimit(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

<p>注意：Limit参数是在2.0版本中新引入的。但在2.0.0版本中，当Batch与Limit同时设置时，似乎还存在一个BUG，初步分析问题原因应该与BatchScanResultCache中的numberOfCompletedRows计数器逻辑处理有关。因此，暂时不建议同时设置这两个参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CacheBlock: RegionServer侧是否要缓存本次Scan所涉及的HFileBlocks</span><br><span class="line">scan.setCacheBlocks(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>e) Raw Scan: 是否可以读取到删除标识以及被删除但尚未被清理的数据</p>
<p>scan.setRaw(true);</p>
<p>MaxResultSize: 从内存占用量的维度限制一次Scan的返回结果集<br>下面的示例代码将返回结果集的最大值设置为5MB：</p>
<p>scan.setMaxResultSize(5 * 1024 * 1024);</p>
<p>Reversed Scan: 反向扫描<br>普通的Scan操作是按照字典顺序从小到大的顺序读取的，而Reversed Scan则恰好相反：</p>
<p>scan.setReversed(true);</p>
<p>带Filter的Scan<br>Filter可以在Scan的结果集基础之上，对返回的记录设置更多条件值，这些条件可以与RowKey有关，可以与列名有关，也可以与列值有关，还可以将多个Filter条件组合在一起，等等。</p>
<p>最常用的Filter是SingleColumnValueFilter，基于它，可以实现如下类似的查询：<br>“返回满足条件{列I:D的值大于等于10}的所有行”<br>Filter丰富了HBase的查询能力，但使用Filter之前，需要注意一点：Filter可能会导致查询响应时延变的不可控制。因为我们无法预测，为了找到一条符合条件的记录，背后需要扫描多少数据量，如果在有效限制了Scan范围区间(通过设置StartRow与StopRow限制)的前提下，该问题能够得到有效的控制。这些信息都要求使用Filter之前应该详细调研自己的业务数据模型。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag"><i class="fa fa-tag"></i> 大数据</a>
              <a href="/tags/HBase/" rel="tag"><i class="fa fa-tag"></i> HBase</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/22/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-22%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8/" rel="prev" title="每日一题@22组合两个表">
      <i class="fa fa-chevron-left"></i> 每日一题@22组合两个表
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/22/JVM%E4%B9%8B%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" rel="next" title="JVM之字节码执行机制">
      JVM之字节码执行机制 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%A5%E9%97%A8HBase"><span class="nav-number">1.</span> <span class="nav-text">入门HBase</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%A7%88"><span class="nav-number">1.1.</span> <span class="nav-text">概览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.1.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8Hbase%EF%BC%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">什么时候用Hbase？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%BA%94%E7%94%A8"><span class="nav-number">1.1.3.</span> <span class="nav-text">内部应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hbase%E6%9E%B6%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">Hbase架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.3.</span> <span class="nav-text">存储设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HLog"><span class="nav-number">1.3.1.</span> <span class="nav-text">HLog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HFile"><span class="nav-number">1.3.2.</span> <span class="nav-text">HFile</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hbase%E5%8D%95%E6%9C%BA%E6%A8%A1%E5%BC%8F%E5%AE%89%E8%A3%85"><span class="nav-number">1.4.</span> <span class="nav-text">Hbase单机模式安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Hbase"><span class="nav-number">1.5.</span> <span class="nav-text">使用Hbase</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hbase%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.6.</span> <span class="nav-text">Hbase数据模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hbase%E8%A1%A8-Schema-%E8%AE%BE%E8%AE%A1%E8%A6%81%E7%82%B9"><span class="nav-number">1.7.</span> <span class="nav-text">Hbase表(Schema)设计要点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hbase%E8%AE%BE%E8%AE%A1%E6%97%B6%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="nav-number">1.7.1.</span> <span class="nav-text">Hbase设计时要考虑的因素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E8%A6%81%E7%82%B9"><span class="nav-number">1.8.</span> <span class="nav-text">设计要点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E5%81%A5%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.8.1.</span> <span class="nav-text">行健设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E7%B0%87%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.8.2.</span> <span class="nav-text">列簇设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E7%B0%87%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE"><span class="nav-number">1.8.3.</span> <span class="nav-text">列簇属性配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-API%E6%93%8D%E4%BD%9C"><span class="nav-number">1.9.</span> <span class="nav-text">Java API操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E4%BC%98%E5%8C%96"><span class="nav-number">1.10.</span> <span class="nav-text">操作优化</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="imarktsh"
      src="https://img-blog.csdnimg.cn/2020053010414625.jpg">
  <p class="site-author-name" itemprop="name">imarktsh</p>
  <div class="site-description" itemprop="description">明天一定学</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">146</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">imarktsh</span>
</div>

    <!-- 网站运行时间的设置 -->
    <span id="timeDate">载入天数...</span>
    <span id="times">载入时分秒...</span>  | It is building your life.
    <script>
        var now = new Date();
        function createtime() {
            var grt= new Date("01/05/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
            now.setTime(now.getTime()+250);
            days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
            hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
            if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
            mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
            seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
            snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
            document.getElementById("timeDate").innerHTML = "已运行 "+dnum+" 天 ";
            document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
    setInterval("createtime()",250);
    </script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>
