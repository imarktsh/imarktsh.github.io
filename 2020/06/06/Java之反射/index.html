<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/128128.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/3232.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/1616.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"onlyear.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Java高级特性——反射定义java中创建对象大概有这几种方式：">
<meta property="og:type" content="article">
<meta property="og:title" content="Java之反射">
<meta property="og:url" content="http://onlyear.com/2020/06/06/Java%E4%B9%8B%E5%8F%8D%E5%B0%84/index.html">
<meta property="og:site_name" content="imarktsh的博客">
<meta property="og:description" content="Java高级特性——反射定义java中创建对象大概有这几种方式：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190527182451455.png#pic_center">
<meta property="og:image" content="https://img-blog.csdn.net/20170513133210763#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020060610582665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200606105957527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200606110016307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/202006061102024.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200606110214392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020060611024178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200606110300274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020060611032445.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200606110348177.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200606110412189.png">
<meta property="article:published_time" content="2020-06-06T03:16:00.000Z">
<meta property="article:modified_time" content="2020-06-06T03:16:52.000Z">
<meta property="article:author" content="imarktsh">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190527182451455.png#pic_center">

<link rel="canonical" href="http://onlyear.com/2020/06/06/Java%E4%B9%8B%E5%8F%8D%E5%B0%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java之反射 | imarktsh的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">imarktsh的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">多沉淀 多复盘</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://onlyear.com/2020/06/06/Java%E4%B9%8B%E5%8F%8D%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://img-blog.csdnimg.cn/2020053010414625.jpg">
      <meta itemprop="name" content="imarktsh">
      <meta itemprop="description" content="明天一定学">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imarktsh的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java之反射
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-06 11:16:00 / 修改时间：11:16:52" itemprop="dateCreated datePublished" datetime="2020-06-06T11:16:00+08:00">2020-06-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Java高级特性——反射"><a href="#Java高级特性——反射" class="headerlink" title="Java高级特性——反射"></a>Java高级特性——反射</h2><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>java中创建对象大概有这几种方式：</p>
<span id="more"></span>

<p>1、使用new关键字：这是我们最常见的也是最简单的创建对象的方式</p>
<p>2、使用Clone的方法：无论何时我们调用一个对象的clone方法，JVM就会创建一个新的对象，将前面的对象的内容全部拷贝进去</p>
<p>3、使用反序列化：当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象</p>
<p>上边是Java中常见的创建对象的三种方式，其实除了上边的三种还有另外一种方式，就是接下来我们要讨论的 “反射”</p>
<p><strong>JAVA反射机制</strong>是在<strong>运行状态中</strong>，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种<strong>动态获取信息</strong>以及动态调用对象方法的功能称为java语言的反射机制。</p>
<p>反射就是把Java类中的各个部分，映射成一个个的Java对象，拿到这些对象后可以做一些事情。</p>
<p>例如，一个类有：成员变量，方法，构造方法，等信息，利用反射技术咱们可以把这些组成部分映射成一个个对象</p>
<p>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>在日常的第三方应用开发过程中，经常会遇到某个类的某个成员变量、方法或是属性是私有的或是只对<strong>系统应用开放</strong>，这时候就可以利用Java的反射机制通过<strong>反射来获取</strong>所需的<strong>私有成员或是方法</strong>。当然，也不是所有的都适合反射，之前就遇到一个案例，通过反射得到的结果与预期不符。阅读源码发现，经过层层调用后在最终返回结果的地方对应用的权限进行了校验，对于没有权限的应用返回值是没有意义的缺省值，否则返回实际值起到保护用户的隐私目的。</p>
<p><img src="https://img-blog.csdnimg.cn/20190527182451455.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20170513133210763#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020060610582665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>Class代表类的实体，在运行的Java应用程序中表示类和接口。在这个类中提供了很多有用的方法，这里对他们简单的分类介绍。<img src="https://img-blog.csdnimg.cn/20200606105957527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200606110016307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/202006061102024.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200606110214392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020060611024178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200606110300274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzA1NzA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h2><p>Field代表类的成员变量（成员变量也称为类的属性）。<img src="https://img-blog.csdnimg.cn/2020060611032445.png" alt="在这里插入图片描述"><strong>Method类</strong><br>Method代表类的方法。<img src="https://img-blog.csdnimg.cn/20200606110348177.png" alt="在这里插入图片描述"></p>
<h2 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h2><p>Constructor代表类的构造方法。<br><img src="https://img-blog.csdnimg.cn/20200606110412189.png" alt="在这里插入图片描述"></p>
<h2 id="反射的使用（这里使用Student类做演示）"><a href="#反射的使用（这里使用Student类做演示）" class="headerlink" title="反射的使用（这里使用Student类做演示）"></a>反射的使用（这里使用Student类做演示）</h2><p>先写一个Student类。</p>
<h2 id="获取Class对象的三种方式"><a href="#获取Class对象的三种方式" class="headerlink" title="获取Class对象的三种方式"></a>获取Class对象的三种方式</h2><p>1Object ——&gt; getClass();<br>2任何数据类型（包括基本数据类型）都有一个“静态”的class属性<br>3 通过Class类的静态方法：forName（String  className）(常用)</p>
<p>是因为Object类中的getClass方法、因为所有类都继承Object类。从而调用Object类来获取</p>
<pre><code class="java">package fanshe;
/**
 * 获取Class对象的三种方式
 * 1 Object ——&gt; getClass();
 * 2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性
 * 3 通过Class类的静态方法：forName（String  className）(常用)
 *
 */
public class Fanshe &#123;
    public static void main(String[] args) &#123;
        //第一种方式获取Class对象  
        Student stu1 = new Student();//这一new 产生一个Student对象，一个Class对象。
        Class stuClass = stu1.getClass();//获取Class对象
        System.out.println(stuClass.getName());
        
        //第二种方式获取Class对象
        Class stuClass2 = Student.class;
        System.out.println(stuClass == stuClass2);//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个
        
        //第三种方式获取Class对象
        try &#123;
            Class stuClass3 = Class.forName(&quot;fanshe.Student&quot;);//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名
            System.out.println(stuClass3 == stuClass2);//判断三种方式是否获取的是同一个Class对象
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
        
    &#125;
&#125;
</code></pre>
<p>注意：在运行期间，一个类，只有一个Class对象产生。<br>三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。<br>通过反射获取构造方法并使用：</p>
<pre><code class="java">student类：
package fanshe;
public class Student &#123;
    //---------------构造方法-------------------
    //（默认的构造方法）
    Student(String str)&#123;
        System.out.println(&quot;(默认)的构造方法 s = &quot; + str);
    &#125;
    
    //无参构造方法
    public Student()&#123;
        System.out.println(&quot;调用了公有、无参构造方法执行了。。。&quot;);
    &#125;
    //有一个参数的构造方法
    public Student(char name)&#123;
        System.out.println(&quot;姓名：&quot; + name);
    &#125;
    
    //有多个参数的构造方法
    public Student(String name ,int age)&#123;
        System.out.println(&quot;姓名：&quot;+name+&quot;年龄：&quot;+ age);//这的执行效率有问题，以后解决。
    &#125;
    
    //受保护的构造方法
    protected Student(boolean n)&#123;
        System.out.println(&quot;受保护的构造方法 n = &quot; + n);
    &#125;
    
    //私有构造方法
    private Student(int age)&#123;
        System.out.println(&quot;私有的构造方法   年龄：&quot;+ age);
    &#125;
 
&#125;

共有6个构造方法；
测试类：
package fanshe;
import java.lang.reflect.Constructor;
/*
 * 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员；
 * 
 * 1.获取构造方法：
 *         1).批量的方法：
 *             public Constructor[] getConstructors()：所有&quot;公有的&quot;构造方法
            public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)
     
 *         2).获取单个的方法，并调用：
 *             public Constructor getConstructor(Class... parameterTypes):获取单个的&quot;公有的&quot;构造方法：
 *             public Constructor getDeclaredConstructor(Class... parameterTypes):获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；
 *         
 *             调用构造方法：
 *             Constructor--&gt;newInstance(Object... initargs)
 */
public class Constructors &#123;
 
    public static void main(String[] args) throws Exception &#123;
        //1.加载Class对象
        Class clazz = Class.forName(&quot;fanshe.Student&quot;);
        //2.获取所有公有构造方法
        System.out.println(&quot;**********************所有公有构造方法*********************************&quot;);
        Constructor[] conArray = clazz.getConstructors();
        for(Constructor c : conArray)&#123;
            System.out.println(c);
        &#125;
        System.out.println(&quot;************所有的构造方法(包括：私有、受保护、默认、公有)***************&quot;);
        conArray = clazz.getDeclaredConstructors();
        for(Constructor c : conArray)&#123;
            System.out.println(c);
        &#125;
        
        System.out.println(&quot;*****************获取公有、无参的构造方法*******************************&quot;);
        Constructor con = clazz.getConstructor(null);
        //1&gt;、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型
        //2&gt;、返回的是描述这个无参构造函数的类对象。
    
        System.out.println(&quot;con = &quot; + con);
        //调用构造方法
        Object obj = con.newInstance();
    //    System.out.println(&quot;obj = &quot; + obj);
    //    Student stu = (Student)obj    
        System.out.println(&quot;******************获取私有构造方法，并调用*******************************&quot;);
        con = clazz.getDeclaredConstructor(char.class);
        System.out.println(con);
        //调用构造方法
        con.setAccessible(true);//暴力访问(忽略掉访问修饰符)
        obj = con.newInstance(&#39;男&#39;);
    
&#125;

后台输出：
**********************所有公有构造方法*********************************
public fanshe.Student(java.lang.String,int)
public fanshe.Student(char)
public fanshe.Student()
************所有的构造方法(包括：私有、受保护、默认、公有)***************
private fanshe.Student(int)
protected fanshe.Student(boolean)
public fanshe.Student(java.lang.String,int)
public fanshe.Student(char)
public fanshe.Student()
fanshe.Student(java.lang.String)
*****************获取公有、无参的构造方法*******************************
con = public fanshe.Student()
调用了公有、无参构造方法执行了。。。
******************获取私有构造方法，并调用*******************************
public fanshe.Student(char)
姓名：男
</code></pre>
<p> 调用方法：</p>
<p>1.获取构造方法：<br>  1).批量的方法：<br>public Constructor[] getConstructors()：所有”公有的”构造方法<br>            public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)<br>  2).获取单个的方法，并调用：<br>public Constructor getConstructor(Class… parameterTypes):获取单个的”公有的”构造方法：<br>public Constructor getDeclaredConstructor(Class… parameterTypes):获取”某个构造方法”可以是私有的，或受保护、默认、公有；<br>  调用构造方法：<br>Constructor–&gt;newInstance(Object… initargs)<br>2、newInstance是 Constructor类的方法（管理构造函数的类）<br>api的解释为：<br>newInstance(Object… initargs)<br>           使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。<br>它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象。并为之调用</p>
<h2 id="获取成员变量并调用"><a href="#获取成员变量并调用" class="headerlink" title="获取成员变量并调用"></a>获取成员变量并调用</h2><pre><code class="java">student类：
package fanshe.field;
 
public class Student &#123;
    public Student()&#123;
        
    &#125;
    //**********字段*************//
    public String name;
    protected int age;
    char sex;
    private String phoneNum;
    
    @Override
    public String toString() &#123;
        return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;, sex=&quot; + sex
                + &quot;, phoneNum=&quot; + phoneNum + &quot;]&quot;;
    &#125;
    
    
&#125;


测试类：
package fanshe.field;
import java.lang.reflect.Field;
/*
 * 获取成员变量并调用：
 * 
 * 1.批量的
 *         1).Field[] getFields():获取所有的&quot;公有字段&quot;
 *         2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；
 * 2.获取单个的：
 *         1).public Field getField(String fieldName):获取某个&quot;公有的&quot;字段；
 *         2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)
 * 
 *      设置字段的值：
 *         Field --&gt; public void set(Object obj,Object value):
 *                     参数说明：
 *                     1.obj:要设置的字段所在的对象；
 *                     2.value:要为字段设置的值；
 * 
 */
public class Fields &#123;
 
        public static void main(String[] args) throws Exception &#123;
            //1.获取Class对象
            Class stuClass = Class.forName(&quot;fanshe.field.Student&quot;);
            //2.获取字段
            System.out.println(&quot;************获取所有公有的字段********************&quot;);
            Field[] fieldArray = stuClass.getFields();
            for(Field f : fieldArray)&#123;
                System.out.println(f);
            &#125;
            System.out.println(&quot;************获取所有的字段(包括私有、受保护、默认的)********************&quot;);
            fieldArray = stuClass.getDeclaredFields();
            for(Field f : fieldArray)&#123;
                System.out.println(f);
            &#125;
            System.out.println(&quot;*************获取公有字段**并调用***********************************&quot;);
            Field f = stuClass.getField(&quot;name&quot;);
            System.out.println(f);
            //获取一个对象
            Object obj = stuClass.getConstructor().newInstance();//产生Student对象--》Student stu = new Student();
            //为字段设置值
            f.set(obj, &quot;刘德华&quot;);//为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot;
            //验证
            Student stu = (Student)obj;
            System.out.println(&quot;验证姓名：&quot; + stu.name);
            
            
            System.out.println(&quot;**************获取私有字段****并调用********************************&quot;);
            f = stuClass.getDeclaredField(&quot;phoneNum&quot;);
            System.out.println(f);
            f.setAccessible(true);//暴力反射，解除私有限定
            f.set(obj, &quot;18888889999&quot;);
            System.out.println(&quot;验证电话：&quot; + stu);
            
        &#125;
    &#125;

后台输出：

************获取所有公有的字段********************
public java.lang.String fanshe.field.Student.name
************获取所有的字段(包括私有、受保护、默认的)********************
public java.lang.String fanshe.field.Student.name
protected int fanshe.field.Student.age
char fanshe.field.Student.sex
private java.lang.String fanshe.field.Student.phoneNum
*************获取公有字段**并调用***********************************
public java.lang.String fanshe.field.Student.name
验证姓名：刘德华
**************获取私有字段****并调用********************************
private java.lang.String fanshe.field.Student.phoneNum
验证电话：Student [name=刘德华, age=0, sex=

由此可见
调用字段时：需要传递两个参数：
Object obj = stuClass.getConstructor().newInstance();//产生Student对象--》Student stu = new Student();
//为字段设置值
f.set(obj, &quot;刘德华&quot;);//为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot;
第一个参数：要传入设置的对象，第二个参数：要传入实参
</code></pre>
<h2 id="获取成员方法并调用"><a href="#获取成员方法并调用" class="headerlink" title="获取成员方法并调用"></a>获取成员方法并调用</h2><pre><code class="java">student类：
package fanshe.method;
 
public class Student &#123;
    //**************成员方法***************//
    public void show1(String s)&#123;
        System.out.println(&quot;调用了：公有的，String参数的show1(): s = &quot; + s);
    &#125;
    protected void show2()&#123;
        System.out.println(&quot;调用了：受保护的，无参的show2()&quot;);
    &#125;
    void show3()&#123;
        System.out.println(&quot;调用了：默认的，无参的show3()&quot;);
    &#125;
    private String show4(int age)&#123;
        System.out.println(&quot;调用了，私有的，并且有返回值的，int参数的show4(): age = &quot; + age);
        return &quot;abcd&quot;;
    &#125;
&#125;

测试类：
package fanshe.method;
 
import java.lang.reflect.Method;
 
/*
 * 获取成员方法并调用：
 * 
 * 1.批量的：
 *         public Method[] getMethods():获取所有&quot;公有方法&quot;；（包含了父类的方法也包含Object类）
 *         public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)
 * 2.获取单个的：
 *         public Method getMethod(String name,Class&lt;?&gt;... parameterTypes):
 *                     参数：
 *                         name : 方法名；
 *                         Class ... : 形参的Class类型对象
 *         public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)
 * 
 *      调用方法：
 *         Method --&gt; public Object invoke(Object obj,Object... args):
 *                     参数说明：
 *                     obj : 要调用方法的对象；
 *                     args:调用方式时所传递的实参；
):
 */
public class MethodClass &#123;
 
    public static void main(String[] args) throws Exception &#123;
        //1.获取Class对象
        Class stuClass = Class.forName(&quot;fanshe.method.Student&quot;);
        //2.获取所有公有方法
        System.out.println(&quot;***************获取所有的”公有“方法*******************&quot;);
        stuClass.getMethods();
        Method[] methodArray = stuClass.getMethods();
        for(Method m : methodArray)&#123;
            System.out.println(m);
        &#125;
        System.out.println(&quot;***************获取所有的方法，包括私有的*******************&quot;);
        methodArray = stuClass.getDeclaredMethods();
        for(Method m : methodArray)&#123;
            System.out.println(m);
        &#125;
        System.out.println(&quot;***************获取公有的show1()方法*******************&quot;);
        Method m = stuClass.getMethod(&quot;show1&quot;, String.class);
        System.out.println(m);
        //实例化一个Student对象
        Object obj = stuClass.getConstructor().newInstance();
        m.invoke(obj, &quot;刘德华&quot;);
        
        System.out.println(&quot;***************获取私有的show4()方法******************&quot;);
        m = stuClass.getDeclaredMethod(&quot;show4&quot;, int.class);
        System.out.println(m);
        m.setAccessible(true);//解除私有限定
        Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参
        System.out.println(&quot;返回值：&quot; + result);
        
        
    &#125;
&#125;
控制台输出：
***************获取所有的”公有“方法*******************
public void fanshe.method.Student.show1(java.lang.String)
public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
public final void java.lang.Object.wait() throws java.lang.InterruptedException
public boolean java.lang.Object.equals(java.lang.Object)
public java.lang.String java.lang.Object.toString()
public native int java.lang.Object.hashCode()
public final native java.lang.Class java.lang.Object.getClass()
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()
***************获取所有的方法，包括私有的*******************
public void fanshe.method.Student.show1(java.lang.String)
private java.lang.String fanshe.method.Student.show4(int)
protected void fanshe.method.Student.show2()
void fanshe.method.Student.show3()
***************获取公有的show1()方法*******************
public void fanshe.method.Student.show1(java.lang.String)
调用了：公有的，String参数的show1(): s = 刘德华
***************获取私有的show4()方法******************
private java.lang.String fanshe.method.Student.show4(int)
调用了，私有的，并且有返回值的，int参数的show4(): age = 20
返回值：abcd

由此可见：
m = stuClass.getDeclaredMethod(&quot;show4&quot;, int.class);//调用制定方法（所有包括私有的），需要传入两个参数，第一个是调用的方法名称，第二个是方法的形参类型，切记是类型。
System.out.println(m);
m.setAccessible(true);//解除私有限定
Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参
System.out.println(&quot;返回值：&quot; + result);//

控制台输出：
***************获取所有的”公有“方法*******************
public void fanshe.method.Student.show1(java.lang.String)
public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
public final void java.lang.Object.wait() throws java.lang.InterruptedException
public boolean java.lang.Object.equals(java.lang.Object)
public java.lang.String java.lang.Object.toString()
public native int java.lang.Object.hashCode()
public final native java.lang.Class java.lang.Object.getClass()
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()
***************获取所有的方法，包括私有的*******************
public void fanshe.method.Student.show1(java.lang.String)
private java.lang.String fanshe.method.Student.show4(int)
protected void fanshe.method.Student.show2()
void fanshe.method.Student.show3()
***************获取公有的show1()方法*******************
public void fanshe.method.Student.show1(java.lang.String)
调用了：公有的，String参数的show1(): s = 刘德华
***************获取私有的show4()方法******************
private java.lang.String fanshe.method.Student.show4(int)
调用了，私有的，并且有返回值的，int参数的show4(): age = 20
返回值：abcd
</code></pre>
<p>其实这里的成员方法：在模型中有属性一词，就是那些setter（）方法和getter()方法。还有字段组成，这些内容在内省中详解</p>
<h2 id="反射main方法"><a href="#反射main方法" class="headerlink" title="反射main方法"></a>反射main方法</h2><pre><code class="java">student类：
package fanshe.main;
 
public class Student &#123;
 
    public static void main(String[] args) &#123;
        System.out.println(&quot;main方法执行了。。。&quot;);
    &#125;
&#125;


测试类：
package fanshe.main;
 
import java.lang.reflect.Method;
 
/**
 * 获取Student类的main方法、不要与当前的main方法搞混了
 */
public class Main &#123;
    
    public static void main(String[] args) &#123;
        try &#123;
            //1、获取Student对象的字节码
            Class clazz = Class.forName(&quot;fanshe.main.Student&quot;);
            
            //2、获取main方法
             Method methodMain = clazz.getMethod(&quot;main&quot;, String[].class);//第一个参数：方法名称，第二个参数：方法形参的类型，
            //3、调用main方法
            // methodMain.invoke(null, new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;);
             //第一个参数，对象类型，因为方法是static静态的，所以为null可以，第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数
             //这里拆的时候将  new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125; 拆成3个对象。。。所以需要将它强转。
             methodMain.invoke(null, (Object)new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;);//方式一
            // methodMain.invoke(null, new Object[]&#123;new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;&#125;);//方式二
            
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        
        
    &#125;
&#125;

控制台输出：
main方法执行了。。。
</code></pre>
<h2 id="反射方法的其它使用之—通过反射运行配置文件内容"><a href="#反射方法的其它使用之—通过反射运行配置文件内容" class="headerlink" title="反射方法的其它使用之—通过反射运行配置文件内容"></a>反射方法的其它使用之—通过反射运行配置文件内容</h2><pre><code class="java">student类：
public class Student &#123;
    public void show()&#123;
        System.out.println(&quot;is show()&quot;);
    &#125;
&#125;

配置文件以txt文件为例子（pro.txt）：
className = cn.fanshe.Student
methodName = show

测试类：
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.Properties;
 
/*
 * 我们利用反射和配置文件，可以使：应用程序更新时，对源码无需进行任何修改
 * 我们只需要将新类发送给客户端，并修改配置文件即可
 */
public class Demo &#123;
    public static void main(String[] args) throws Exception &#123;
        //通过反射获取Class对象
        Class stuClass = Class.forName(getValue(&quot;className&quot;));//&quot;cn.fanshe.Student&quot;
        //2获取show()方法
        Method m = stuClass.getMethod(getValue(&quot;methodName&quot;));//show
        //3.调用show()方法
        m.invoke(stuClass.getConstructor().newInstance());
        
    &#125;
    
    //此方法接收一个key，在配置文件中获取相应的value
    public static String getValue(String key) throws IOException&#123;
        Properties pro = new Properties();//获取配置文件的对象
        FileReader in = new FileReader(&quot;pro.txt&quot;);//获取输入流
        pro.load(in);//将流加载到配置文件对象中
        in.close();
        return pro.getProperty(key);//返回根据key获取的value值
    &#125;
&#125;

控制台输出：
is show()

需求：
当我们升级这个系统时，不要Student类，而需要新写一个Student2的类时，这时只需要更改pro.txt的文件内容就可以了。代码就一点不用改动

要替换的student2类：
public class Student2 &#123;
    public void show2()&#123;
        System.out.println(&quot;is show2()&quot;);
    &#125;
&#125;

配置文件更改为：
className = cn.fanshe.Student2
methodName = show2
控制台输出：
is show2();
</code></pre>
<h2 id="反射方法的其它使用之—通过反射越过泛型检查"><a href="#反射方法的其它使用之—通过反射越过泛型检查" class="headerlink" title="反射方法的其它使用之—通过反射越过泛型检查"></a>反射方法的其它使用之—通过反射越过泛型检查</h2><p>泛型用在编译期，编译过后泛型擦除（消失掉）。所以是可以通过反射越过泛型检查的</p>
<pre><code class="java">测试类：
import java.lang.reflect.Method;
import java.util.ArrayList;
 
/*
 * 通过反射越过泛型检查
 * 
 * 例如：有一个String泛型的集合，怎样能向这个集合中添加一个Integer类型的值？
 */
public class Demo &#123;
    public static void main(String[] args) throws Exception&#123;
        ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;();
        strList.add(&quot;aaa&quot;);
        strList.add(&quot;bbb&quot;);
        
    //    strList.add(100);
        //获取ArrayList的Class对象，反向的调用add()方法，添加数据
        Class listClass = strList.getClass(); //得到 strList 对象的字节码 对象
        //获取add()方法
        Method m = listClass.getMethod(&quot;add&quot;, Object.class);
        //调用add()方法
        m.invoke(strList, 100);
        
        //遍历集合
        for(Object obj : strList)&#123;
            System.out.println(obj);
        &#125;
    &#125;
&#125;

控制台输出：
aaa
bbb
100
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_38259539/article/details/71799078">原文链接</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/06/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-12%E4%B9%B0%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA2/" rel="prev" title="每日一题@12买股票最佳时机2">
      <i class="fa fa-chevron-left"></i> 每日一题@12买股票最佳时机2
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/06/Redis-%E4%BA%8C/" rel="next" title="Redis(二)">
      Redis(二) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84"><span class="nav-number">1.</span> <span class="nav-text">Java高级特性——反射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">2.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E9%80%94"><span class="nav-number">3.</span> <span class="nav-text">用途</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text">Class类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Field%E7%B1%BB"><span class="nav-number">5.</span> <span class="nav-text">Field类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Constructor%E7%B1%BB"><span class="nav-number">6.</span> <span class="nav-text">Constructor类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E8%BF%99%E9%87%8C%E4%BD%BF%E7%94%A8Student%E7%B1%BB%E5%81%9A%E6%BC%94%E7%A4%BA%EF%BC%89"><span class="nav-number">7.</span> <span class="nav-text">反射的使用（这里使用Student类做演示）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">8.</span> <span class="nav-text">获取Class对象的三种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%B9%B6%E8%B0%83%E7%94%A8"><span class="nav-number">9.</span> <span class="nav-text">获取成员变量并调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E5%B9%B6%E8%B0%83%E7%94%A8"><span class="nav-number">10.</span> <span class="nav-text">获取成员方法并调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84main%E6%96%B9%E6%B3%95"><span class="nav-number">11.</span> <span class="nav-text">反射main方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B6%E5%AE%83%E4%BD%BF%E7%94%A8%E4%B9%8B%E2%80%94%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%BF%90%E8%A1%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="nav-number">12.</span> <span class="nav-text">反射方法的其它使用之—通过反射运行配置文件内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B6%E5%AE%83%E4%BD%BF%E7%94%A8%E4%B9%8B%E2%80%94%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%B6%8A%E8%BF%87%E6%B3%9B%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="nav-number">13.</span> <span class="nav-text">反射方法的其它使用之—通过反射越过泛型检查</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="imarktsh"
      src="https://img-blog.csdnimg.cn/2020053010414625.jpg">
  <p class="site-author-name" itemprop="name">imarktsh</p>
  <div class="site-description" itemprop="description">明天一定学</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">146</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">imarktsh</span>
</div>

    <!-- 网站运行时间的设置 -->
    <span id="timeDate">载入天数...</span>
    <span id="times">载入时分秒...</span>  | It is building your life.
    <script>
        var now = new Date();
        function createtime() {
            var grt= new Date("01/05/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
            now.setTime(now.getTime()+250);
            days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
            hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
            if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
            mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
            seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
            snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
            document.getElementById("timeDate").innerHTML = "已运行 "+dnum+" 天 ";
            document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
    setInterval("createtime()",250);
    </script><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>
